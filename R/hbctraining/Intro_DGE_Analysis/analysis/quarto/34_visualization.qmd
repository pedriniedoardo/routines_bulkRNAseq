---
title: "Advanced visualizations"
html:
    embed-resources: true
editor: visual
---

## Learning Objectives

-   Setup results data for application of visualization techniques
-   Describe different data visualization useful for exploring results from a DGE analysis
-   Create a volcano plot to evaluate relationship amongst DGE statistics
-   Create a heatmap to illustrate expression changes of differentially expressed genes

## Visualizing the results

When we are working with large amounts of data it can be useful to display that information graphically to gain more insight. During this lesson, we will get you started with some basic and more advanced plots commonly used when exploring differential gene expression data, however, many of these plots can be helpful in visualizing other types of data as well.

We will be working with three different data objects we have already created in earlier lessons:

-   Metadata for our samples (a dataframe): `meta`
-   Normalized expression data for every gene in each of our samples (a matrix): `normalized_counts`
-   Tibble versions of the DESeq2 results we generated in the last lesson: `res_tableOE_tb` and `res_tableKD_tb`

First, let's create a metadata tibble from the data frame (don't lose the row names!)

```{r}
#| warning: false
#| message: false

# load the libraries
library(DESeq2)
library(tidyverse)
library(RColorBrewer)
library(pheatmap)
library(tximport)
library(ggplot2)
library(ggrepel)
library(limma)
library(ashr)
library(ComplexUpset)
library(UpSetR)
library(ComplexHeatmap)
library(DEGreport)
```

```{r}
# read in the data
# meta <- readRDS("../../out/object/metadata.rds")

# read in the object
txi <- readRDS("../../out/object/txi.rds")
meta <- readRDS("../../out/object/metadata.rds")

## Create DESeq2Dataset object
dds <- DESeqDataSetFromTximport(txi, colData = meta, design = ~ sampletype)
dds

## Run analysis
dds <- DESeq(dds)

# save the dds after runnign DESeq()
saveRDS(dds,"../../out/object/dds_full.rds")

# res_tableOE <- readRDS("../../out/object/res_tableOE_shrAlt.rds")
res_tableOE <- readRDS("../../out/object/res_tableOE.rds")
res_tableOE_tb <- res_tableOE %>%
  data.frame() %>%
  rownames_to_column(var="gene") %>% 
  as_tibble()

res_tableKO <- readRDS("../../out/object/res_tableKO.rds")
res_tableKO_tb <- res_tableKO %>%
  data.frame() %>%
  rownames_to_column(var="gene") %>% 
  as_tibble()

tx2gene <- read.delim("../../data/tx2gene_grch38_ens94.txt")

### Set thresholds
padj.cutoff <- 0.05
sigOE <- res_tableOE_tb %>%
        dplyr::filter(padj < padj.cutoff)

```

```{r}
# add the rwnames as variable to the table
mov10_meta <- meta %>% 
              rownames_to_column(var="samplename") %>% 
              as_tibble()

mov10_meta
```

Next, let's bring in a column with gene symbols to the `normalized_counts` object, so we can use them to label our plots. Ensembl IDs are great for many things, but the gene symbols are much more recognizable to us, as biologists.

```{r}
# DESeq2 creates a matrix when you use the counts() function
## First convert normalized_counts to a data frame and transfer the row names to a new column called "gene"
normalized_counts <- counts(dds, normalized=T) %>% 
                     data.frame() %>%
                     rownames_to_column(var="gene") 

head(normalized_counts)
  
# Next, merge together (ensembl IDs) the normalized counts data frame with a subset of the annotations in the tx2gene data frame (only the columns for ensembl gene IDs and gene symbols)
grch38annot <- tx2gene %>% 
               dplyr::select(ensgene, symbol) %>% 
               dplyr::distinct()

head(grch38annot)

## This will bring in a column of gene symbols
# normalized_counts <- merge(normalized_counts, grch38annot, by.x="gene", by.y="ensgene")
# normalized_counts <- normalized_counts %>%
#                      as_tibble()
# create a tibble for the normalized counts
normalized_counts <- normalized_counts %>%
  left_join(grch38annot,by = c("gene" = "ensgene")) %>%
  as_tibble()

head(normalized_counts)
```

> **NOTE:** A possible alternative to the above:
>
> ``` r
> normalized_counts <- counts(dds, normalized=T) %>% 
>                      data.frame() %>%
>                      rownames_to_column(var="gene") %>%
>                      as_tibble() %>%
>                      left_join(grch38annot, by=c("gene" = "ensgene"))
> ```

### Plotting signicant DE genes

One way to visualize results would be to simply plot the expression data for a handful of genes. We could do that by picking out specific genes of interest or selecting a range of genes.

#### **Using DESeq2 `plotCounts()` to plot expression of a single gene**

To pick out a specific gene of interest to plot, for example MOV10, we can use the `plotCounts()` from DESeq2. `plotCounts()` requires that the gene specified matches the original input to DESeq2, which in our case was Ensembl IDs.

```{r}
# Find the Ensembl ID of MOV10
grch38annot[grch38annot$symbol == "MOV10", "ensgene"]

# Plot expression for single gene
plotCounts(dds, gene="ENSG00000155363", intgroup="sampletype") 
```

Here is an alternative approach using the data extracted from the `dds` object. Notice that with this approach we can plot any number of genes.

```{r}
# extract the lut from the object
lut <- colData(dds) %>%
  as.data.frame() %>%
  rownames_to_column("sample")

# define the GOIs
GOI <- c("ENSG00000155363")

# define the MR per sample
MR <- counts(dds,normalized=T) %>%
  as.data.frame() %>%
  rownames_to_column("symbol") %>%
  pivot_longer(names_to = "sample",values_to = "exp",-symbol)%>%
  group_by(sample)%>%
  summarise(MR = sum(exp)/10^6)

# plot the data following the methods implemented in the plotCounts funciton from DESeq2
# Normalized counts plus a pseudocount of 0.5 are shown by default.
df_counts <- counts(dds,normalized=T) %>%
  as.data.frame() %>%
  rownames_to_column("symbol") %>%
  filter(symbol %in% GOI) %>%
  pivot_longer(names_to = "sample",values_to = "count",-symbol) %>%
  # add the milion reads per sample
  left_join(MR,by = "sample") %>%
  left_join(lut,by = "sample") %>%
  # this is the adjustment of the reads
  mutate(count_norm_adj = count + 0.5)

# plot the data adjusted norm counts or norm counts
df_counts %>%
  ggplot(aes(x=sampletype,y = count_norm_adj))+
  # ggplot(aes(x=sampletype,y = count))+
  geom_boxplot(outlier.shape = NA)+
  geom_point(position = position_jitter(width = 0.1),alpha=0.6)+facet_wrap(~symbol,scales = "free") +
  scale_y_continuous(trans = "log1p",breaks = c(2000,20000,200000)) +
  theme_bw()+
  theme(strip.background = element_blank(),
        panel.border = element_rect(colour = "black", fill = NA))
```

> This DESeq2 function only allows for plotting the counts of a single gene at a time, and is not flexible regarding the appearance.

#### **Using ggplot2 to plot expression of a single gene**

If you wish to change the appearance of this plot, we can save the output of `plotCounts()` to a variable specifying the `returnData=TRUE` argument, then use `ggplot()`:

```{r}
# Save plotcounts to a data frame object
d <- plotCounts(dds, gene="ENSG00000155363", intgroup="sampletype", returnData=TRUE)

# What is the data output of plotCounts()?
d

# compare it with the value exprected from the manual extraction
df_counts

# Plot the MOV10 normalized counts, using the samplenames (rownames(d) as labels)
ggplot(d, aes(x = sampletype, y = count, color = sampletype)) + 
    geom_point(position=position_jitter(w = 0.1,h = 0)) +
    geom_text_repel(aes(label = rownames(d))) + 
    theme_bw() +
    ggtitle("MOV10") +
    theme(plot.title = element_text(hjust = 0.5))
```

> Note that in the plot below (code above), we are using `geom_text_repel()` from the `ggrepel` package to label our individual points on the plot.

> If you are interested in plotting the expression of multiple genes all together, please refer to [the short lesson linked here](top20_genes-expression_plotting.md) where we demo this for the top 20 most significantly expressed genes.

#### Using `ggplot2` to plot multiple genes (e.g. top 20)

Often it is helpful to check the expression of multiple genes of interest at the same time. This often first requires some data wrangling. We are going to plot the normalized count values for the **top 20 differentially expressed genes (by padj values)**. To do this, we first need to determine the gene names of our top 20 genes by ordering our results and extracting the top 20 genes (by padj values):

```{r}
## Order results by padj values
top20_sigOE_genes <- res_tableOE_tb %>% 
  arrange(padj) %>% 	#Arrange rows by padj values
  slice(1:20) %>% # Extract the first 20 genes
  pull(gene) 		#Extract character vector of ordered genes

top20_sigOE_genes
```

Then, we can extract the normalized count values for these top 20 genes:

```{r}
## normalized counts for top 20 significant genes
top20_sigOE_norm <- normalized_counts %>%
        filter(gene %in% top20_sigOE_genes)

top20_sigOE_norm
```

Now that we have the normalized counts for each of the top 20 genes for all 8 samples, to plot using `ggplot()`, we need to gather the counts for all samples into a single column to allow us to give ggplot the one column with the values we want it to plot. The `gather()` function in the **tidyr** package will perform this operation and will output the normalized counts for all genes for *Mov10_oe_1* listed in the first 20 rows, followed by the normalized counts for *Mov10_oe_2* in the next 20 rows, so on and so forth.

::: {#fig-melt fig-align="center"}
![melt](img/melt_wide_to_long_format.png){width="500"}
:::

```{r}
# Gathering the columns to have normalized counts to a single column
gathered_top20_sigOE <- top20_sigOE_norm %>%
  gather(colnames(top20_sigOE_norm)[2:9], key = "samplename", value = "normalized_counts")

## check the column header in the "gathered" data frame
head(gathered_top20_sigOE)

# as alternative I can also use the pivot_longer function
gathered_top20_sigOE_alt <- top20_sigOE_norm %>%
  pivot_longer(names_to = "samplename",values_to = "normalized_counts",-c(gene,symbol))

head(gathered_top20_sigOE_alt)

```

Now, if we want our counts colored by sample group, then we need to combine the metadata information with the melted normalized counts data into the same data frame for input to `ggplot()`:

```{r}
gathered_top20_sigOE <- inner_join(mov10_meta, gathered_top20_sigOE)
gathered_top20_sigOE

gathered_top20_sigOE_alt <- inner_join(mov10_meta, gathered_top20_sigOE_alt)
gathered_top20_sigOE_alt
```

The `inner_join()` will merge 2 data frames with respect to the "samplename" column, i.e. a column with the same column name in both data frames. Now that we have a data frame in a format that can be utilised by ggplot easily, let's plot!

```{r}
## plot using ggplot2
ggplot(gathered_top20_sigOE) +
  geom_point(aes(x = symbol, y = normalized_counts, color = sampletype)) +
  # scale_y_log10() +
  scale_y_continuous(trans = "log10") +
  xlab("Genes") +
  ylab("log10 Normalized Counts") +
  ggtitle("Top 20 Significant DE Genes") +
  theme_bw() +
	theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
	theme(plot.title = element_text(hjust = 0.5))

# using the date generate from pivot_longer
ggplot(gathered_top20_sigOE_alt) +
  geom_point(aes(x = symbol, y = normalized_counts, color = sampletype)) +
  # scale_y_log10() +
  scale_y_continuous(trans = "log10") +
  xlab("Genes") +
  ylab("log10 Normalized Counts") +
  ggtitle("Top 20 Significant DE Genes") +
  theme_bw() +
	theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
	theme(plot.title = element_text(hjust = 0.5))
```

### Heatmap

In addition to plotting subsets, we could also extract the normalized values of *all* the significant genes and plot a heatmap of their expression using `pheatmap()`.

```{r}
### Extract normalized expression for significant genes from the OE and control samples (2:4 and 7:9)
norm_OEsig <- normalized_counts[,c(1:4,7:9)] %>% 
              dplyr::filter(gene %in% sigOE$gene)  

head(norm_OEsig)
```

Now let's draw the heatmap using `pheatmap`:

```{r}
### Set a color palette
heat_colors <- brewer.pal(6, "YlOrRd")

### Run pheatmap using the metadata data frame for the annotation
pheatmap::pheatmap(norm_OEsig[2:7], 
    color = heat_colors, 
    cluster_rows = T, 
    show_rownames = F,
    annotation = meta, 
    border_color = NA, 
    fontsize = 10, 
    scale = "row", 
    fontsize_row = 10, 
    height = 20)
```

> *NOTE:* There are several additional arguments we have included in the function for aesthetics. One important one is `scale="row"`, in which Z-scores are plotted, rather than the actual normalized count value.
>
> Z-scores are computed on a gene-by-gene basis by subtracting the mean and then dividing by the standard deviation. The Z-scores are computed **after the clustering**, so that it only affects the graphical aesthetics and the color visualization is improved.

Another useful package I have been using for plotting Heatmaps, is `ComplexHeatmaps`. Here is a sample snippet that allow

```{r}
# pull the degs
DEG_2 <- sigOE %>%
  pull(gene)

# z-scale the expression matrix.
# I generally use the vst transformed data for this plot, but to replicate the vignette I am using the normalized counts matrix
# as in the vignette, focus only on the control on OE samples

# mat_filter <- assay(vds_filter) %>%
#   data.frame() %>%
#   as.matrix()

# filter only the samples of interest
mat_filter <- normalized_counts[,c(1:4,7:9)] %>%
  column_to_rownames("gene") %>%
  as.matrix()

# filter only the genes of interest
mat_shr <- mat_filter[rownames(mat_filter) %in% DEG_2, ]

# z scale the matrix by gene (row)
mat2_shr <- (mat_shr - rowMeans(mat_shr))/rowSds(mat_shr,useNames = TRUE)

# generate the metadata fro the new matrix
meta_sample <- data.frame(colname = colnames(mat2_shr)) %>% 
  left_join(meta %>%
              rownames_to_column(var="sample"),
            by=c("colname"="sample"))

# make the column of the matrix more readable
# colnames(mat2_shr) <- meta_sample$Sample.name

# build the column annotation for the matrix
column_ha_shr <- HeatmapAnnotation(treat = meta_sample$sampletype,  
                                   col = list(treat = c("control" = "gray",
                                                        "MOV10_overexpression" = "black"))) 

ht2_shr <- Heatmap(mat2_shr, show_column_names = T,
                   name = "exp", 
                   column_title = "sigOE",
                   # col = viridis::viridis(option = "turbo",n = 10),
                   # col = colorRamp2(c(-2, 0, 2), c("yellow", "orange", "red")), 
                   col = heat_colors,
                   # row_names_gp = gpar(fontsize = 3),
                   top_annotation = column_ha_shr,
                   show_row_names = F,
                   # cluster_rows = F, 
                   # right_annotation = row_ha, 
                   # row_split = rep(c(1,2,3,4),c(2,3,4,7))
                   
) 

draw(ht2_shr,heatmap_legend_side = "left",annotation_legend_side = "left") 
```

### Volcano plot

The above plot would be great to look at the expression levels of a good number of genes, but for more of a global view there are other plots we can draw. A commonly used one is a volcano plot; in which you have the log transformed adjusted p-values plotted on the y-axis and log2 fold change values on the x-axis.

To generate a volcano plot, we first need to have a column in our results data indicating whether or not the gene is considered differentially expressed based on p-adjusted values and we will include a log2fold change here.

```{r}
## Obtain logical vector where TRUE values denote padj values < 0.05 and fold change > 1.5 in either direction
res_tableOE_tb2 <- res_tableOE_tb %>%
  dplyr::mutate(threshold_OE = padj < 0.05 & abs(log2FoldChange) >= 0.58)

head(res_tableOE_tb2)
```

Now we can start plotting. The `geom_point` object is most applicable, as this is essentially a scatter plot:

```{r}
## Volcano plot
ggplot(res_tableOE_tb2) +
    geom_point(aes(x = log2FoldChange, y = -log10(padj), colour = threshold_OE)) +
    ggtitle("Mov10 overexpression") +
    xlab("log2 fold change") + 
    ylab("-log10 adjusted p-value") +
    #scale_y_continuous(limits = c(0,50)) +
    theme(legend.position = "none",
          plot.title = element_text(size = rel(1.5), hjust = 0.5),
          axis.title = element_text(size = rel(1.25)))  
```

This is a great way to get an overall picture of what is going on, but what if we also wanted to know where the top 10 genes (lowest padj) in our DE list are located on this plot? We could label those dots with the gene name on the Volcano plot using `geom_text_repel()`.

First, we need to order the res_tableOE tibble by `padj`, and add an additional column to it, to include on those gene names we want to use to label the plot.

```{r}
## Add all the gene symbols as a column from the grch38 table using left_join
# res_tableOE_tb3 <- bind_cols(, symbol=grch38annot$symbol[match(res_tableOE_tb$gene, grch38annot$ensgene)])
res_tableOE_tb3 <- res_tableOE_tb2 %>%
  left_join(grch38annot,by = c("gene" = "ensgene")) %>%
  ## Create an empty column to indicate which genes to label
  dplyr::mutate(genelabels = "") %>%
  ## Sort by padj values 
  dplyr::arrange(padj)

## Populate the genelabels column with contents of the gene symbols column for the first 10 rows, i.e. the top 10 most significantly expressed genes
res_tableOE_tb3$genelabels[1:10] <- as.character(res_tableOE_tb3$symbol[1:10])

head(res_tableOE_tb3,n=15)
```

Next, we plot it as before with an additional layer for `geom_text_repel()` wherein we can specify the column of gene labels we just created.

```{r}
ggplot(res_tableOE_tb3, aes(x = log2FoldChange, y = -log10(padj))) +
    geom_point(aes(colour = threshold_OE)) +
    geom_text_repel(aes(label = genelabels)) +
    ggtitle("Mov10 overexpression") +
    xlab("log2 fold change") + 
    ylab("-log10 adjusted p-value") +
    theme(legend.position = "none",
          plot.title = element_text(size = rel(1.5), hjust = 0.5),
          axis.title = element_text(size = rel(1.25))) 
```

------------------------------------------------------------------------

> ### An R package for visualization of DGE results
>
> The Bioconductor package [`DEGreport`](https://bioconductor.org/packages/release/bioc/html/DEGreport.html) can use the DESeq2 results output to make the top20 genes and the volcano plots generated above by writing much fewer lines of code. The caveat of these functions is you lose the ability to customize plots as we have demonstrated above.
>
> If you are interested, the example code below shows how you can use DEGreport to create similar plots. **Note that this is example code, do not run.**

> ``` r
> DEGreport::degPlot(dds = dds, res = res, n = 20, xs = "type", group = "condition") # dds object is output from DESeq2
>
> DEGreport::degVolcano(
>     data.frame(res[,c("log2FoldChange","padj")]), # table - 2 columns
>     plot_text = data.frame(res[1:10,c("log2FoldChange","padj","id")])) # table to add names
>     
> # Available in the newer version for R 3.4
> DEGreport::degPlotWide(dds = dds, genes = row.names(res)[1:5], group = "condition")
> ```

Test the functions with the updated arguments.

```{r}
# pull the gene ids 
GOI <- res_tableOE_tb %>%
  arrange(padj) %>%
  pull(gene) %>%
  .[1:5]

# plot counts split
DEGreport::degPlot(dds, genes = GOI, xs = "sampletype", group = "sampletype") + theme(axis.text.x = element_text(angle = 45,hjust = 1))

# plot the volcano
DEGreport::degVolcano(res_tableOE_tb3[,c("log2FoldChange","padj")], # table - 2 columns
                      plot_text = res_tableOE_tb3[1:10,c("log2FoldChange","padj","symbol")]) # table to add names

# plot counts
DEGreport::degPlotWide(counts = dds, genes = GOI, group = "sampletype")

```

