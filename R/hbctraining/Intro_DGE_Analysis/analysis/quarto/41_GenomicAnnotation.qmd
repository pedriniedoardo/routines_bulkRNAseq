---
title: "Genomic annotations"
html:
    embed-resources: true
editor: visual
---

## Learning Objectives:

-   Discuss the available genomic annotation databases and the different types if information stored
-   Compare and contrast the tools available for accessing genomic annotation databases
-   Apply various R packages for retrieval of genomic annotations

# Genomic annotations

The analysis of next-generation sequencing results requires associating genes, transcripts, proteins, etc. with functional or regulatory information. To perform functional analysis on gene lists, we often need to obtain gene identifiers that are compatible with the tools we wish to use and this is not always trivial. Here, we discuss **ways in which you can obtain gene annotation information and some of the advantages and disadvantages of each method**.

## Databases

We retrieve information on the processes, pathways, etc. (for which a gene is involved in) from the necessary database where the information is stored. The database you choose will be dependent on what type of information you are trying to obtain. Examples of databases that are often queried, include:

**General databases**

Offer comprehensive information on genome features, feature coordinates, homology, variant information, phenotypes, protein domain/family information, associated biological processes/pathways, associated microRNAs, etc.:

-   **Ensembl** (use Ensembl gene IDs)
-   **NCBI** (use Entrez gene IDs)
-   **UCSC**
-   **EMBL-EBI**

**Annotation-specific databases**

Provide annotations related to a specific topic:

-   **Gene Ontology (GO):** database of gene ontology biological processes, cellular components and molecular functions - based on Ensembl or Entrez gene IDs or official gene symbols
-   **KEGG:** database of biological pathways - based on Entrez gene IDs
-   **MSigDB:** database of gene sets
-   **Reactome:** database of biological pathways
-   **Human Phenotype Ontology:** database of genes associated with human disease
-   **CORUM:** database of protein complexes for human, mouse, rat
-   **...**

This is by no means an exhaustive list, there are many other databases available that are not listed here.

## Genome builds

Before you begin your search through any of these databases, you should know which **build of the genome** was used to generate your gene list and make sure you use the **same build for the annotations** during functional analysis. When a new genome build is acquired, the names and/or coordinate location of genomic features (gene, transcript, exon, etc.) may change. Therefore, the annotations regarding genome features (gene, transcript, exon, etc.) is genome-build specific and we need to make sure that our annotations are obtained from the appropriate resource.

For example, if we used the GRCh38 build of the human genome to quantify gene expression used for differential expression analysis, then we should use the **same GRCh38 build** of the genome to convert between gene IDs and to identify annotations for each of the genes.

## Tools for accessing databases

Within R, there are many popular packages used for gene/transcript-level annotation. These packages provide tools that take the list of genes you provide and retrieve information for each gene using one or more of the databases listed above.

### Annotation tools: for accessing/querying annotations from a specific databases

| Tool | Description | Pros | Cons |
|:-----------------:|:----------------|:----------------|:-----------------:|
| [**org.Xx.eg.db**](https://bioconductor.org/packages/release/bioc/vignettes/AnnotationDbi/inst/doc/IntroToAnnotationPackages.pdf) | Query gene feature information for the organism of interest | gene ID conversion, biotype and coordinate information | only latest genome build available |
| [**EnsDb.Xx.vxx**](http://bioconductor.org/packages/devel/bioc/vignettes/ensembldb/inst/doc/ensembldb.html) | Transcript and gene-level information directly fetched from Ensembl API (similar to TxDb, but with filtering ability and versioned by Ensembl release) | easy functions to extract features, direct filtering | Not the most up-to-date annotations, more difficult to use than some packages |
| [**TxDb.Xx.UCSC.hgxx.knownGene**](https://bioconductor.org/packages/release/bioc/html/GenomicFeatures.html) | UCSC database for transcript and gene-level information or can create own *TxDb* from an SQLite database file using the *GenomicFeatures* package | feature information, easy functions to extract features | only available current and recent genome builds - can create your own, less up-to-date with annotations than Ensembl |
| [**annotables**](https://github.com/stephenturner/annotables) | Gene-level feature information immediately available for the human and model organisms | super quick and easy gene ID conversion, biotype and coordinate information | static resource, not updated regularly |
| [**biomaRt**](https://bioconductor.org/packages/release/bioc/html/biomaRt.html) | An R package version of the Ensembl [BioMart online tool](http://www.ensembl.org/biomart/martview/70dbbbe3f1c5389418b5ea1e02d89af3) | all Ensembl database information available, all organisms on Ensembl, wealth of information |  |

### Interface tools: for accessing/querying annotations from multiple different annotation sources

-   **AnnotationDbi:** queries the *OrgDb*, *TxDb*, *Go.db*, *EnsDb*, and *BioMart* annotations.\
-   **AnnotationHub:** queries large collection of whole genome resources, including ENSEMBL, UCSC, ENCODE, Broad Institute, KEGG, NIH Pathway Interaction Database, etc.

> **NOTE:** These are both packages that can be used to create the `tx2gene` files we had you download at the beginning of this workshop.

## AnnotationDbi

AnnotationDbi is an R package that provides an interface for connecting and querying various annotation databases using SQLite data storage. The AnnotationDbi packages can query the *OrgDb*, *TxDb*, *EnsDb*, *Go.db*, and *BioMart* annotations. There is helpful [documentation](https://bioconductor.org/packages/release/bioc/vignettes/AnnotationDbi/inst/doc/IntroToAnnotationPackages.pdf) available to reference when extracting data from any of these databases.

### org.Hs.eg.db

There are a plethora of organism-specific *orgDb* packages, such as `org.Hs.eg.db` for human and `org.Mm.eg.db` for mouse, and a list of organism databases can be found [here](https://www.bioconductor.org/packages/release/BiocViews.html#___OrgDb). These databases are best for converting gene IDs or obtaining GO information for current genome builds, but not for older genome builds. These packages provide the current builds corresponding to the release date of the package, and update every 6 months. If a package is not available for your organism of interest, you can create your own using *AnnotationHub*.

```{r}
# Load libraries
library(org.Hs.eg.db)
library(AnnotationDbi)

# Check object metadata
org.Hs.eg.db
```

We can see the metadata for the database by just typing the name of the database, including the species, last updates for the different source information, and the source urls. Note the KEGG data from this database was last updated in 2011, so may not be the best site for KEGG pathway information.

We can easily extract information from this database using *AnnotationDbi* with the methods: `columns`, `keys`, `keytypes`, and `select`. For example, we will use our `org.Hs.eg.db` database to acquire information, but know that the same methods work for the *TxDb*, *Go.db*, *EnsDb*, and *BioMart* annotations.

```{r}
#| warning: false
#| message: false

# load the libraries
library(DESeq2)
library(tidyverse)
library(RColorBrewer)
library(pheatmap)
library(tximport)
library(ggplot2)
library(ggrepel)
library(limma)
library(ashr)
library(ComplexUpset)
library(UpSetR)
library(ComplexHeatmap)
library(DEGreport)
```

```{r}
# read in the pairwise DE analysis
res_tableOE_tb <- readRDS("../../out/object/res_tableOE.rds") %>%
  data.frame() %>%
  rownames_to_column("gene")

dim(res_tableOE_tb)

# Return the Ensembl IDs for a set of genes
annotations_orgDb <- AnnotationDbi::select(org.Hs.eg.db, # database
                                     keys = res_tableOE_tb$gene,  # data to use for retrieval
                                     columns = c("SYMBOL", "ENTREZID","GENENAME"), # information to retreive for given data
                                     keytype = "ENSEMBL") # type of data given in 'keys' argument

dim(annotations_orgDb)
head(annotations_orgDb)
```

We started from at about 57K genes in our results table, and the dimensions of our resulting annotation data frame also look quite similar. Let's take a peek to see if we actually returned annotations for each individual Ensembl gene ID that went in to the query:

```{r}
# length(which(is.na(annotations_orgDb$SYMBOL)))

annotations_orgDb %>%
  mutate(missing = is.na(SYMBOL)) %>%
  group_by(missing) %>%
  summarise(n = n())
```

Looks like more than half of the input genes did not return any annotations. This is because the OrgDb family of database are primarily based on mapping using Entrez Gene identifiers. If you look at some of the Ensembl IDs from our query that returned NA, these map to pseudogenes (i.e [ENSG00000265439](https://useast.ensembl.org/Homo_sapiens/Gene/Summary?g=ENSG00000265439;r=6:44209766-44210063;t=ENST00000580735)) or non-coding RNAs (i.e. [ENSG00000265425](http://useast.ensembl.org/Homo_sapiens/Gene/Summary?g=ENSG00000265425;r=18:68427030-68436918;t=ENST00000577835)). The difference is due to the fact that each database implements different computational approaches for generating the gene builds. Let's get rid of those NA entries:

```{r}
# # Determine the indices for the non-NA genes
# non_na_idx <- which(is.na(annotations_orgDb$SYMBOL) == FALSE)
# # Return only the genes with annotations using indices
# annotations_orgDb <- annotations_orgDb[non_na_idx, ]

annotations_orgDb2 <- annotations_orgDb %>%
  filter(!is.na(SYMBOL))

head(annotations_orgDb2)
dim(annotations_orgDb2)
```

You may have also noted the *warning* returned: *'select()' returned 1:many mapping between keys and columns*. This is always going to happen with converting between different gene IDs (i.e. one geneID can map to more than one identifier in another databse) . Unless we would like to keep multiple mappings for a single gene, then we probably want to de-duplicate our data before using it.

```{r}
# # Determine the indices for the non-duplicated genes
# non_duplicates_idx <- which(duplicated(annotations_orgDb2$SYMBOL) == FALSE)
# # Return only the non-duplicated genes using indices
# annotations_orgDb3 <- annotations_orgDb2[non_duplicates_idx, ]

annotations_orgDb3 <- annotations_orgDb2 %>%
  filter(!duplicated(SYMBOL))

head(annotations_orgDb3)
dim(annotations_orgDb3)
```

### EnsDb.Hsapiens.v86

To generate the Ensembl annotations, the *EnsDb* database can also be easily queried using AnnotationDbi. You will need to decide the release of Ensembl you would like to query. We know that our data is for GRCh38, and the most current *EnsDb* release for GRCh38 in Bioconductor is release 86, so we can install this database. All Ensembl releases are listed [here](http://useast.ensembl.org/info/website/archives/index.html). **NOTE: this is not the most current release of GRCh38 in the Ensembl database, but it's as current as we can obtain through AnnotationDbi.**

Since we are using *AnnotationDbi* to query the database, we can use the same functions that we used previously:

```{r}
# Load the library
library(EnsDb.Hsapiens.v86)

# Check object metadata
EnsDb.Hsapiens.v86

# Explore the fields that can be used as keys
keytypes(EnsDb.Hsapiens.v86)
```

Now we can return all gene IDs for our gene list:

```{r}
# Return the Ensembl IDs for a set of genes
annotations_edb <- AnnotationDbi::select(EnsDb.Hsapiens.v86,
                                           keys = res_tableOE_tb$gene,
                                           columns = c("SYMBOL", "ENTREZID","GENEBIOTYPE"),
                                           keytype = "GENEID")

head(annotations_edb)
dim(annotations_edb)
```

We can check for NA entries, and find that there are none:

```{r}
# length(which(is.na(annotations_edb$SYMBOL) == FALSE))

annotations_edb %>%
  mutate(missing = is.na(SYMBOL)) %>%
  group_by(missing) %>%
  summarise(n = n())
```

Then we can again deduplicate, to remove the gene symbols which appear more than once:

```{r}
# # Determine the indices for the non-duplicated genes
# non_duplicates_idx <- which(duplicated(annotations_edb$SYMBOL) == FALSE)
# # Return only the non-duplicated genes using indices
# annotations_edb2 <- annotations_edb[non_duplicates_idx, ]

annotations_edb2 <- annotations_edb %>%
  dplyr::filter(!duplicated(SYMBOL))

head(annotations_edb2)
dim(annotations_edb2)
```

> **NOTE:** In this case we used the same build but a slightly older release, and we found little discrepancy. If your analysis was conducted using an older genome build (i.e hg19), but used a newer build for annotation some genes may be found to be not annotated (NA). Some of the genes have changed names in between versions (due to updates and patches), so may not be present in the newer version of the database.

## AnnotationHub

AnnotationHub is a wonderful resource for accessing genomic data or querying large collection of whole genome resources, including ENSEMBL, UCSC, ENCODE, Broad Institute, KEGG, NIH Pathway Interaction Database, etc. All of this information is stored and easily accessible by directly connecting to the database.

To get started with AnnotationHub, we first load the library and connect to the database:

```{r}
# Load libraries
library(AnnotationHub)
library(ensembldb)

# Connect to AnnotationHub
ah <- AnnotationHub()

hubCache(ah)
hubUrl(ah)
```

> #### What is a cache?
>
> A cache is used in R to store data or a copy of the data so that future requests can be served faster without having to re-run a lengthy computation.
>
> The `AnnotationHub()` command creates a client that manages a local cache of the database, helping with quick and reproducible access. When encountering question `AnnotationHub does not exist, create directory?`, you can anwser either `yes` (create a permanent location to store cache) or `no` (create a temporary location to store cache). `hubCache(ah)` gets the file system location of the local AnnotationHub cache. `hubUrl(ah)` gets the URL for the online hub.

To see the types of information stored inside our database, we can just type the name of the object:

```{r}
# Explore the AnnotationHub object
ah
```

Using the output, you can get an idea of the information that you can query within the AnnotationHub object: Notice the note on retrieving records with `object[[AH*]]` - this will be how we can **extract a single record** from the AnnotationHub object.

If you would like to see more information about any of the classes of data you can extract that information as well. For example, if you wanted to **determine all species information available**, you could explore that within the AnnotationHub object:

```{r}
# Explore all species information available
unique(ah$species) %>% length()
unique(ah$species) %>% head()
```

In addition to species information, there is also additional information about the type of Data Objects and the Data Providers:

```{r}
# Explore the types of Data Objects available
unique(ah$rdataclass)

# Explore the Data Providers
unique(ah$dataprovider)
```

Now that we know the types of information available from AnnotationHub we can query it for the information we want using the `query()` function. Let's say we would like to **return the Ensembl `EnsDb` information for Human**. To return the records available, we need to use the terms as they are output from the `ah` object to extract the desired data.

```{r}
# Query AnnotationHub
human_ens <- query(ah, c("Homo sapiens", "EnsDb"))
human_ens
```

The query retrieves all **hits for the `EnsDb` objects**, and you will see that they are listed by the release number. The most current release for GRCh38 is Ensembl98 and AnnotationHub offers that as an option to use. However, if you look at options for older releases, for Homo sapiens it only go back as far as Ensembl 87. This is fine if you are using GRCh38, however if you were using an older genome build like hg19/GRCh37, you would need to load the `EnsDb` package if available for that release or you might need to build your own with `ensembldb`.

In our case, we are looking for the latest Ensembl release so that the annotations are the most up-to-date. To extract this information from AnnotationHub, we can use the AnnotationHub ID to **subset the object**:

```{r}
# Extract annotations of interest
human_ens <- human_ens[["AH75011"]]
human_ens
```

Now we can use `ensembldb` functions to extract the information at the gene, transcript, or exon levels. We are interested in the gene-level annotations, so we can extract that information as follows:

```{r}
# Extract gene-level information
genes(human_ens, return.type = "data.frame") %>%
  head()
```

But note that it is just as easy to get the transcript- or exon-level information:

```{r}
# Extract transcript-level information
transcripts(human_ens, return.type = "data.frame") %>% head()

# Extract exon-level information
exons(human_ens, return.type = "data.frame") %>% head()
```

To **obtain an annotation data frame** using AnnotationHub, we'll use the `genes()` function, but only keep selected columns and filter out rows to keep those corresponding to our gene identifiers in our results file:

```{r}
# Create a gene-level dataframe 
annotations_ahb <- genes(human_ens, return.type = "data.frame")  %>%
  dplyr::select(gene_id, gene_name, entrezid, gene_biotype) %>% 
  dplyr::filter(gene_id %in% res_tableOE_tb$gene)

head(annotations_ahb)
```

This dataframe looks like it should be fine as it is, but we look a little closer we will notice that the column containing Entrez identifiers is a list, and in fact there are many Ensembl identifiers that map to more than one Entrez identifier!

```{r}
# Wait a second, we don't have one-to-one mappings!
class(annotations_ahb$entrezid)

# which(map(annotations_ahb$entrezid, length) > 1) 
# which(map(annotations_ahb$entrezid, length) > 1) %>% length()

annotations_ahb %>%
  mutate(test = map(entrezid,function(x){
    length(x) > 1
  }) %>% unlist()) %>%
  dplyr::filter(test == T)
```

So what do we do here? And why do we have this problem? An answer from the [Ensembl Help Desk](https://www.biostars.org/p/16505/) is that this occurs when we cannot choose a perfect match; ie when we have two good matches, but one does not appear to match with a better percentage than the other. In that case, we assign both matches. What we will do is choose to **keep the first identifier for these multiple mapping cases**.

```{r}
# annotations_ahb$test <- map(annotations_ahb$entrezid,1) %>%  unlist()

test <- annotations_ahb %>%
  mutate(entrezid_first = map(entrezid,function(x){
    x[1]
  }) %>% unlist())

dim(test)
head(test)
```

> **NOTE:** Not all databases handle multiple mappings in the same way. For example, if we used the OrgDb instead of the EnsDb:
>
> ```         
> human_orgdb <- query(ah, c("org.Hs.eg.db.sqlite"))
> human_orgdb <- human_orgdb[["AH116710"]]
> annotations_orgdb <- AnnotationDbi::select(human_orgdb, res_tableOE_tb$gene, c("SYMBOL", "GENENAME", "ENTREZID"), "ENSEMBL")
> ```
>
> We would find that multiple mapping entries would be automatically reduced to one-to-one. We would also find that more than half of the input genes do not return any annotations. This is because the OrgDb family of database are primarily based on mapping using Entrez Gene identifiers. Since our data is based on Ensembl mappings, using the OrgDb would result in a loss of information.

```{r}
human_orgdb <- query(ah, c("org.Hs.eg.db.sqlite"))
human_orgdb

# pick the correct record version
human_orgdb <- human_orgdb[["AH117067"]]
annotations_orgdb <- AnnotationDbi::select(human_orgdb, res_tableOE_tb$gene, c("SYMBOL", "GENENAME", "ENTREZID"), "ENSEMBL")

head(annotations_orgdb)
dim(annotations_orgdb)

annotations_orgdb %>%
  mutate(test = is.na(SYMBOL)) %>%
  group_by(test) %>%
  summarise(n = n())
```

Let's take a look and see how many of our Ensembl identifiers have an associated gene symbol, and how many of them are unique:

```{r}
# which(is.na(annotations_ahb$gene_name)) %>% length()
# which(duplicated(annotations_ahb$gene_name)) %>% length()

annotations_ahb %>%
  group_by(is.na(gene_name)) %>%
  summarise(n = n())

annotations_ahb %>%
  group_by(duplicated(gene_name)) %>%
  summarise(n = n())
```

Let's identify the non-duplicated genes and only keep the ones that are not duplicated:

```{r}
# Determine the indices for the non-duplicated genes
# non_duplicates_idx <- which(duplicated(annotations_ahb$gene_name) == FALSE)

# Return only the non-duplicated genes using indices
# annotations_ahb <- annotations_ahb[non_duplicates_idx, ]

# How many rows does annotations_ahb have?
annotations_ahb %>% nrow()

# How many rows are we left with after removing?
annotations_ahb2 <- annotations_ahb %>% 
  dplyr::filter(!duplicated(gene_name))

annotations_ahb2 %>% nrow()
```

Finally, it would be good to know **what proportion of the Ensembl identifiers map to an Entrez identifier**:

```{r}
# Determine how many of the Entrez column entries are NA
# which(is.na(annotations_ahb2$entrezid)) %>%  length()
annotations_ahb2 %>%
  group_by(is.na(entrezid)) %>%
  summarise(n = n())

```

That's more than half of our genes! If we plan on using Entrez ID results for downstream analysis, we should definitely keep this in mind. If you look at some of the Ensembl IDs from our query that returned NA, these map to pseudogenes (i.e [ENSG00000265439](https://useast.ensembl.org/Homo_sapiens/Gene/Summary?g=ENSG00000265439;r=6:44209766-44210063;t=ENST00000580735)) or non-coding RNAs (i.e. [ENSG00000265425](http://useast.ensembl.org/Homo_sapiens/Gene/Summary?g=ENSG00000265425;r=18:68427030-68436918;t=ENST00000577835)). The discrepancy (which we can expect to observe) between databases is due to the fact that each implements its own different computational approaches for generating the gene builds.

### Using AnnotationHub to create our tx2gene file

To create our `tx2gene` file, we would need to use a combination of the methods above and merge two dataframes together. For example:

```{r}
# Create a transcript dataframe
txdb <- transcripts(human_ens, return.type = "data.frame") %>%
  dplyr::select(tx_id, gene_id)

dim(txdb)
head(txdb)
 
txdb2 <- txdb[grep("ENST", txdb$tx_id),]

dim(txdb2)
head(txdb2)
 
# Create a gene-level dataframe
genedb <- genes(human_ens, return.type = "data.frame")  %>%
  dplyr::select(gene_id, gene_name)

dim(genedb)
head(genedb)
 
# Merge the two dataframes together
annotations <- inner_join(txdb2, genedb)

dim(annotations)
head(annotations)
```

In this lesson our focus has been using annotation packages to extract information mainly just for gene ID conversion for the different tools that we use downstream. Many of the annotation packages we have presented have much more information than what we need for functional analysis and we have only just scratched the surface here. It's good to know the capabilities of the tools we use, so we encourage you to spend some time exploring these packages to become more familiar with them.

> **NOTE:** The *annotables* package is a super easy annotation package to use. It is not updated frequently, so it's not great for getting the most up-to-date information for the current builds and does not have information for other organisms than human and mouse, but is a quick way to get annotation information.
>
> ``` r
> # Install package
> BiocManager::install("annotables")
>
> # Load library
> library(annotables)
>
> # Access previous build of annotations
> grch38
> ```

Test the package

```{r}
# Load library
library(annotables)

# Access previous build of annotations
dim(grch38)
head(grch38)
```
